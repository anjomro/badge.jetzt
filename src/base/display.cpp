//
// Created by Anton Mrosek on 19.05.25.
//

#include "display.h"
#include "button.h"

namespace display
{
    Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

    uint8_t current_y = 0;

    void init()
    {
        oled.begin(SSD1306_SWITCHCAPVCC, 0x3C);
        oled.clearDisplay();
        oled.setTextSize(1);
        oled.setTextColor(SSD1306_WHITE);
        oled.display();
    }

    Adafruit_SSD1306& get()
    {
        return oled;
    }

    void clearDisplay()
    {
        oled.clearDisplay();
        current_y = 0;
    }

    void println(const char* text)
    {
        oled.setCursor(0, current_y);
        oled.print(text);
        current_y += getCurrentCharHeight();
    }

    int availableLineCount()
    {
        // 32px / font height
        // Only count full lines
        return SCREEN_HEIGHT / getCurrentCharHeight();
    }

    void setTextColor(uint16_t color, uint16_t background) {
        oled.setTextColor(color, background);
    }

    void drawSplashImage() 
    {
        // 'chaos_128x32', 128x32px
        const unsigned char epd_bitmap_chaos_128x32 [] PROGMEM = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x3f, 0xc0, 0x1f, 0x80, 0x00, 0xfe, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x3f, 0xe0, 0x7f, 0xe0, 0x03, 0xff, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x3f, 0xc0, 0xff, 0xf0, 0x03, 0xfe, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x3f, 0x81, 0xff, 0xf8, 0x07, 0xff, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x7f, 0xa3, 0xe9, 0xf8, 0x07, 0xe7, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x7e, 0x73, 0xfb, 0xfc, 0x0f, 0xc3, 0x00, 0x00, 
            0x00, 0x0c, 0x00, 0x30, 0x00, 0x00, 0x03, 0xf0, 0x7c, 0xf7, 0xf7, 0xf8, 0x0f, 0xc0, 0x00, 0x00, 
            0x00, 0x3e, 0x00, 0x78, 0x00, 0x00, 0x03, 0xf0, 0xfd, 0xf7, 0xf7, 0xf8, 0x0f, 0xf0, 0x00, 0x00, 
            0x00, 0x3f, 0x00, 0xfc, 0x00, 0x00, 0xff, 0xf0, 0xfd, 0xff, 0xfc, 0xfb, 0x07, 0xfc, 0x00, 0x00, 
            0x00, 0x7f, 0x00, 0xfc, 0x00, 0x01, 0xff, 0xf0, 0xfd, 0xff, 0xff, 0xfb, 0x07, 0xff, 0x00, 0x00, 
            0x00, 0x7f, 0x00, 0xfe, 0x00, 0x01, 0xff, 0xf0, 0xff, 0xff, 0xf7, 0xf7, 0x83, 0xff, 0xc0, 0x00, 
            0x00, 0x7c, 0x00, 0x7e, 0x03, 0x07, 0xff, 0xf0, 0xff, 0xff, 0xef, 0xf7, 0x80, 0xff, 0xe0, 0x00, 
            0x00, 0x7c, 0x00, 0x3e, 0x07, 0xdf, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xf7, 0x80, 0x3f, 0xf0, 0x00, 
            0x00, 0x78, 0x00, 0x3e, 0x07, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xef, 0x80, 0x07, 0xf0, 0x00, 
            0x00, 0x78, 0x00, 0x3e, 0x0f, 0xdf, 0x03, 0xf3, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0xf0, 0x00, 
            0x00, 0x7c, 0x00, 0x3e, 0x0f, 0xdf, 0x03, 0xf3, 0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0xe8, 0x00, 
            0x00, 0x7e, 0x00, 0x7e, 0x1f, 0x9e, 0x03, 0xf3, 0xff, 0xfe, 0xff, 0xff, 0x80, 0x61, 0xf8, 0x00, 
            0x00, 0x7f, 0xff, 0xfe, 0x1f, 0x9f, 0x03, 0xf7, 0xf0, 0x7e, 0xff, 0xff, 0x81, 0xf3, 0xf8, 0x00, 
            0x00, 0x3f, 0xff, 0xfc, 0x3f, 0x1f, 0x01, 0xf7, 0xe0, 0x7e, 0x7f, 0xff, 0x03, 0xff, 0xb8, 0x00, 
            0x00, 0x3f, 0xff, 0xfc, 0x3f, 0x1f, 0x03, 0xff, 0xe0, 0x3f, 0x3f, 0xfe, 0x03, 0xff, 0xff, 0xfe, 
            0x20, 0x1f, 0xff, 0xf8, 0x7e, 0x1f, 0x03, 0xff, 0xe0, 0x3f, 0x1f, 0xfe, 0x01, 0xf0, 0x80, 0x02, 
            0x3e, 0x0f, 0xff, 0xa0, 0x7c, 0x1f, 0x03, 0xff, 0xc0, 0x3f, 0x0f, 0xf8, 0x00, 0xfe, 0xbb, 0xb6, 
            0x0f, 0x01, 0xff, 0x80, 0x78, 0x1f, 0x03, 0xff, 0xc0, 0x1f, 0x03, 0xe0, 0x00, 0x3e, 0x9b, 0x36, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0xbb, 0x76, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x8a, 0x16, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfe, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 528)
        const int epd_bitmap_allArray_LEN = 1;
        const unsigned char* epd_bitmap_allArray[1] = {
            epd_bitmap_chaos_128x32
        };

        oled.drawBitmap(0, 0, epd_bitmap_chaos_128x32, 128, 32, SSD1306_WHITE);
    }

    int makeMenu(const char* title, const char* options[], int numOptions)
    {
        clearDisplay();
        if (title != nullptr && strlen(title) > 0)
        {
            setCursor(0, current_y);
            print(title);
            // Display for 60ms per character, + 500ms for reaction time
            delay(60 * strlen(title) + 500);
            display();
            clearDisplay();
        }
        int choosen = -1;
        int selected = 0;
        bool updated = true;

        // Repeat until a valid option is selected
        while (choosen == -1)
        {
            if (updated)
            {
                drawMenu(options, numOptions, selected);
                updated = false;
            }
            if (button::down(BTN1))
            {
                // Move cursor up, or wrap around
                selected = mod(selected - 1, numOptions);
                updated = true;
                delay(200);
            }
            else if (button::down(BTN2))
            {
                // Move cursor down, or wrap around
                selected = mod(selected + 1, numOptions);
                updated = true;
                delay(200);
            }
            else if (button::down(BTN3))
            {
                // Select option
                choosen = selected;
            }
        }
        return choosen;
    }


    void drawMenu(const char* options[], int numOptions, int selected)
    {
        clearDisplay();

        // Calculate how many lines we can display
        int maxLines = availableLineCount();
        int startIndex = 0;

        // Determine which options to display (create a scroll window)
        if (numOptions > maxLines)
        {
            // Try to center the selected item
            startIndex = selected - maxLines / 2;

            // Adjust if we would go out of bounds
            if (startIndex < 0)
            {
                startIndex = 0;
            }
            else if (startIndex + maxLines > numOptions)
            {
                startIndex = numOptions - maxLines;
            }
        }

        // Display visible options
        for (int i = 0; i < min(maxLines, numOptions); i++)
        {
            int optionIndex = startIndex + i;
            setCursor(0, i * getCurrentCharHeight());

            // Show selection marker
            if (optionIndex == selected)
            {
                print(">");
            }
            else
            {
                print(" ");
            }

            // Print the full option text
            setCursor(8, i * getCurrentCharHeight());
            print(options[optionIndex]);
        }

        // Update the display
        display();
    }
}
